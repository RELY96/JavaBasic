package j10_APITest;

// API : Application Programming Interface
// ** String1
// 1) 선언(정의)과 인스턴스 => 묵시적선언, 명시적선언
// 참조형변수 - 주소값 갖고 있음
// 불변(immutable) 속성을 가짐(주소가 변하는 것에 비해 string이 존재하는, 할당된 공간은 변하지 않음
// => 새로운 리터럴 값을 입력하면, 원래 값이 사라지는 게 아니라 새로운 공간에 새로운 리터럴값을 주는 거임(참조형string) =/= String buffer(일정한, 정해진 기본 크기(공간)을 갖고 유지함)

// String buffer : 기본적인 할당된 크기를 갖고 있음(값을 수정하면서 사용 -> 변하는 속성, mutable) '=' String build

public class Ex01_String01_literal {

	public static void main(String[] args) {
		// 1) 묵시적 선언(지금까지 해왔던 String 선언들)
		String s1 = "그린";
		String s2 = "그린";
		
//-----------------------------------------------------------------------------------//

		// 2) 명시적 선언(new 연산자 사용!)
		String s3 = new String("그린"); //String인스턴스 생성하며 매개변수 안에 "그린" 넣어줌
		String s4 = new String("그린");
		
		// 2-1) 값 출력 비교
		System.out.printf("s1: %s, s2: %s, s3: %s, s4: %s \n",s1,s2,s3,s4);
		
//-----------------------------------------------------------------------------------//
		
		// 2-2) 값 변경 전/후 비교
		s1="홍길동"; // s1값을 변경
		s3="홍길동"; // "
		// 처음 new 해서 사용할때만 다른 주소가 생성되는거지, 생성 후 값을 변경하면 해당 값의 주소와 값이 new한거에 들어가는 것! => 같아짐
		// => 값이 바뀌면 "그 값에 따라 ★주소값이 바뀜★"
		// String : *공간 자체를 바꾸는게 아님(그래서 ★변경불가), 원래 "공간"에 새 주소와 새 값을 받는 것
		
		// String은 리터럴 공간에 주소가 생성되서, 그 주소를 전달 받는 것(주소의 값)
		
		//======================================================================//
		
		// 그래서 static 공간의 String 공간은 변하지 않지만, heap의 리터럴 공간의 String 주소는 리터럴 값에 따라 바뀔 수 있다 => 같은 리터럴이면 같은 번짓수를 갖게 되며,
		// 인스턴스가 첫 생성됐을 때는 리터럴 값 형태가 같아도 주소가 다르지만
		// 인스턴스가 생성된 후 리터럴 값의 String을 바꾸면 주소와 값도 리터럴값에 따라 바뀐다.
		
		// ** 주소는 ==가 아닌 equals로 비교해야함
		
		//======================================================================//
		
		// 3) if문으로 각 인스턴스 비교
		/* 3-1) 묵시와 묵시 비교 T/F*/
		if(s1==s2) System.out.println("s1 == s2 : True");
		else System.out.println("s1 == s2 : False");
		// 묵시적 선언 저장공간 -> 참조형 변수 : 주소값 저장, "그린"이라는 똑같은 결과값이 있으면 똑같은 주소 할당 -> 같은 값이 됨!(같은 그린)
		
		//-----------------------------------------------------------------------------------//

		/* 3-2) 묵시와 명시 비교 F/T*/
		if(s1==s3) System.out.println("s1 == s3 : True");
		else System.out.println("s1 == s3 : False");
		// 1. 홍길동이 예를 들어, heap 영역에 50번지 값으로 저장됐으면, s1주소와 값은 50번지 홍길동으로 바뀜
		// 2. s3의 생성이 끝난 후, 50번지 홍길동이라는 리터럴값이 해당 s3에 들어가게 됨
		
		//-----------------------------------------------------------------------------------//
		
		/* 3-3) 명시와 명시 비교 F/F*/
		if(s3==s4) System.out.println("s3 == s4 : True");
		else System.out.println("s3 == s4 : False \n \n");
		// 명시적 저장공간 : new할때 마다 새로운 인스턴스 공간 마련
		
		//======================================================================//
		
		// 4) 값(리터럴)의 비교(heap공간에 저장된 리터럴 값)
		if(s1.equals(s2)) System.out.println("s1 == s2 : True"); /*주소값인 String은 equals 비교 해야함*/
		else System.out.println("s1 == s2 : False"); // F
		
		if(s1.equals(s3)) System.out.println("s1 == s3 : True"); //리터럴 값과 주소 값 같은 "홍길동"으로 바꿔줘서 True!
		else System.out.println("s1 == s3 : False"); // T
		
		if(s1.equals(s4)) System.out.println("s1 == s4 : True");
		else System.out.println("s1 == s4 : False"); // F
		
		if(s2.equals(s3)) System.out.println("s2 == s3 : True");
		else System.out.println("s2 == s3 : False"); // F
		
		//======================================================================//
		
		// 5) 문자열의 길이(length,글자수) 비교 / 문자열 연산(+ 만 가능)
		s2="My name is Green";
		s3="안녕 하세요";
		System.out.println("* 영문 글자수: "+s2.length()); // 16
		System.out.println("* 한글 글자수: "+s3.length()); // 6
		
		int i =100, j=123;
		System.out.println("* +이용 문자열 연산: "+s1+s2+s3+s4+i+j); //문자열 연산으로 i,j자동 적용됨 / 100123
		System.out.println("* +이용 문자열 연산: "+s1+s2+s3+s4+(i+j)); //우선순위 적용으로 i,j간 산술연산 가능 / 223
	} //main

} //class
